/* ----------------------------------------------------------------------------
 *         ATMEL Microcontroller Software Support 
 * ----------------------------------------------------------------------------
 * Copyright (c) 2008, Atmel Corporation
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Atmel's name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 */

//------------------------------------------------------------------------------
/// \dir "Basic USART Hardware Handshaking Project"
///
/// !!!Purpose
///
/// This example demonstrates the hardware handshaking mode (i.e. RTS/CTS)
/// provided by the USART peripherals on AT91 microcontrollers. The practical
/// use of hardware handshaking is that it allows to stop transfer on the USART
/// without losing any data in the process. This is very useful for applications
/// that need to program slow memories for example.
///
/// !!!Requirements
///
/// This example can be used on any AT91 evaluation kit, except when they do
/// not provide an USART serial port (i.e. on AT91SAM9261-EK, AT91SAM7L-EK and
/// AT91SAM7L-STK).
///
/// !!!Description
///
/// The provided program uses hardware handshaking mode to regulate the data
/// rate of an incoming file transfer. A terminal application, such as
/// hyperterminal, is used to send a text file to the device (without any
/// protocol such as X-modem). The device will enforce the configured
/// bytes per second (bps) rate with its Request To Send (RTS) line.
///
/// Whenever the data rate meet or exceed the configurable threshold, the device
/// stops receiving data on the USART. Since no buffer is provided to the PDC,
/// this will set the RTS line, telling the computer to stop sending data. Each
/// second, the current data rate and total number of bytes received are
/// displayed; the transfer is also restarted.
///
/// Note that the device may receive slightly less bytes than the actual file
/// size, depending on the nature of the file. This does NOT mean that bytes
/// have been lost: this is simply an issue with how line breaks are transmitted
/// by the terminal. It is therefore better to use binary files, as they most
/// often do not contain line breaks. For example, send one of the object files
/// generated by the compiler.
///
/// !!!Usage
///
/// -# Build the program and download it inside the evaluation board. Please
///    refer to the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6224.pdf">SAM-BA User Guide</a>,
///    the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6310.pdf">GNU-Based Software Development</a>
///    application note or to the <a href="ftp://ftp.iar.se/WWWfiles/arm/Guides/EWARM_UserGuide.ENU.pdf">IAR EWARM User Guide</a>,
///    depending on your chosen solution.
/// -# Connect a serial cable to the USART0 port on the evaluation kit. It will
///    most often be labeled "RS232 COM port".
/// -# On the computer, open and configure a terminal application (e.g.
///    HyperTerminal on Microsoft Windows) with these settings:
///       - 115200 bauds
///       - 8 data bits
///       - No parity
///       - 1 stop bit
///       - Hardware flow control (RTS/CTS)
/// -# Start the application. The following traces shall appear on the terminal:
///    \code
///    -- Basic USART Hardware Handshaking Project xxx --
///    -- AT91xxxxxx-xx
///    -- Compiled: xxx xx xxxx xx:xx:xx --
///    Bps:    0; Tot:      0
///    \endcode
/// -# Send a file in text format to the device. On HyperTerminal, this is done
///    by selecting "Transfer -> Send Text File" (this does not prevent you from
///    sending binary files). The transfer will start and the device will update
///    the bps and total counts on the terminal.
/// -# Whenever the transfer is complete, the total number of bytes received
///    should match the size of the sent file (unless it is a text file, see
///    explanation in description section).
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//         Headers
//------------------------------------------------------------------------------

#include <board.h>
#include <pio/pio.h>
#include <usart/usart.h>
#include <tc/tc.h>
#include <aic/aic.h>
#include <pmc/pmc.h>
#include <utility/trace.h>

#include <stdio.h>

//------------------------------------------------------------------------------
//         Local definition
//------------------------------------------------------------------------------
#ifndef AT91C_ID_TC0
#if defined(AT91C_ID_TC012)
    #define AT91C_ID_TC0 AT91C_ID_TC012
#elif defined(AT91C_ID_TC)
    #define AT91C_ID_TC0 AT91C_ID_TC
#else
    #error Pb define ID_TC
#endif
#endif


/// Maximum Bytes Per Second (BPS) rate that will be forced using the CTS pin.
#define MAX_BPS             500

/// Size of the receive buffer used by the PDC, in bytes.
#define BUFFER_SIZE         1

//------------------------------------------------------------------------------
//         Local variables
//------------------------------------------------------------------------------

/// Pins to configure for the application.
const Pin pins[] = {
    PINS_DBGU,
    PIN_USART0_RXD,
    PIN_USART0_TXD,
    PIN_USART0_CTS,
    PIN_USART0_RTS
};

/// Number of bytes received between two timer ticks.
volatile unsigned int bytesReceived = 0;

/// Receive buffer.
unsigned char pBuffer[BUFFER_SIZE];

/// String buffer.
char pString[24];

//------------------------------------------------------------------------------
//         Local functions
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/// Interrupt handler for USART0. Increments the number of bytes received in the
/// current second and starts another transfer if the desired bps has not been
/// met yet.
//------------------------------------------------------------------------------
void ISR_Usart0(void)
{
    unsigned int status;

    // Read USART status
    status = AT91C_BASE_US0->US_CSR;

    // Receive buffer is full
    if ((status & AT91C_US_RXBUFF) == AT91C_US_RXBUFF) {

        bytesReceived += BUFFER_SIZE;

        // Restart transfer if BPS is not high enough
        if (bytesReceived < MAX_BPS) {

            USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
        }
        // Otherwise disable interrupt
        else {

            AT91C_BASE_US0->US_IDR = AT91C_US_RXBUFF;
        }
    }
}

//------------------------------------------------------------------------------
/// Interrupt handler for TC0. Displays the number of bytes received during the
/// last second and the total number of bytes received, then restarts a read
/// transfer on the USART if it was stopped.
//------------------------------------------------------------------------------
void ISR_Tc0(void)
{
    unsigned int status;
    static unsigned int bytesTotal = 0;

    // Read TC0 status
    status = AT91C_BASE_TC0->TC_SR;

    // RC compare
    if ((status & AT91C_TC_CPCS) == AT91C_TC_CPCS) {
            
        // Display info
        bytesTotal += bytesReceived;
        sprintf(pString, "Bps: %4u; Tot: %6u\r", bytesReceived, bytesTotal);
        USART_WriteBuffer(AT91C_BASE_US0, pString, sizeof(pString));
        bytesReceived = 0;

        // Resume transfer if needed
        if (AT91C_BASE_US0->US_RCR == 0) {

            USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
            AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
        }
    }
}

//------------------------------------------------------------------------------
/// Configures USART0 in hardware handshaking mode, asynchronous, 8 bits, 1 stop
/// bit, no parity, 115200 bauds and enables its transmitter and receiver.
//------------------------------------------------------------------------------
void ConfigureUsart0(void)
{
    unsigned int mode = AT91C_US_USMODE_HWHSH
                        | AT91C_US_CLKS_CLOCK
                        | AT91C_US_CHRL_8_BITS
                        | AT91C_US_PAR_NONE
                        | AT91C_US_NBSTOP_1_BIT
                        | AT91C_US_CHMODE_NORMAL;

    // Enable the peripheral clock in the PMC
    PMC_EnablePeripheral(AT91C_ID_US0);

    // Configure the USART in the desired mode @115200 bauds
    USART_Configure(AT91C_BASE_US0, mode, 115200, BOARD_MCK);

    // Configure the RXBUFF interrupt
    AIC_ConfigureIT(AT91C_ID_US0, 0, ISR_Usart0);
    AIC_EnableIT(AT91C_ID_US0);

    // Enable receiver & transmitter
    USART_SetTransmitterEnabled(AT91C_BASE_US0, 1);
    USART_SetReceiverEnabled(AT91C_BASE_US0, 1);
}

//------------------------------------------------------------------------------
/// Configures Timer Counter 0 (TC0) to generate an interrupt every second. This
/// interrupt will be used to display the number of bytes received on the USART.
//------------------------------------------------------------------------------
void ConfigureTc0(void)
{
    unsigned int div, tcclks;

    // Enable TC0 peripheral clock
    PMC_EnablePeripheral(AT91C_ID_TC0);

    /// Configure TC for a 1s (= 1Hz) tick
    TC_FindMckDivisor(1, BOARD_MCK, &div, &tcclks);
    TC_Configure(AT91C_BASE_TC0, tcclks | AT91C_TC_CPCTRG);
    AT91C_BASE_TC0->TC_RC = (BOARD_MCK / (2 * div));

    // Configure interrupt on RC compare
    AIC_ConfigureIT(AT91C_ID_TC0, 0, ISR_Tc0);
    AT91C_BASE_TC0->TC_IER = AT91C_TC_CPCS;
    AIC_EnableIT(AT91C_ID_TC0);
}

//------------------------------------------------------------------------------
//         Global functions
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/// Application entry point. Configures USART0 in hardware handshaking mode and
/// Timer Counter 0 to generate an interrupt every second. Then, starts the first
/// transfer on the USART and wait in an endless loop.
/// \return Unused.
//------------------------------------------------------------------------------
int main(void)
{
    // Configure pins
    PIO_Configure(pins, PIO_LISTSIZE(pins));

    // Configure USART0 and display startup trace
    ConfigureUsart0();
    printf("-- Basic USART Hardware Handshaking Project %s --\n\r", SOFTPACK_VERSION);
    printf("-- %s\n\r", BOARD_NAME);
    printf("-- Compiled: %s %s --\n\r", __DATE__, __TIME__);

    // Configure TC0 to generate a 1s tick
    ConfigureTc0();

    // Start receiving data and start timer
    USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
    AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
    TC_Start(AT91C_BASE_TC0);

    // Infinite loop
    while (1);
}

